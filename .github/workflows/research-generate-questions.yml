name: Research & Generate Questions

on:
  schedule:
    # Ejecutar diariamente a las 6:00 AM UTC (1:00 AM Colombia)
    - cron: '0 6 * * *'

  workflow_dispatch:
    inputs:
      country:
        description: 'Target country code'
        required: true
        type: choice
        options:
          - CO
          - MX
          - BR
          - US
        default: 'CO'
      category:
        description: 'Question category'
        required: true
        type: choice
        options:
          - mathematics
          - science
          - history
          - geography
          - computers
          - general_knowledge
        default: 'mathematics'
      num_questions:
        description: 'Number of source questions to fetch'
        required: false
        type: number
        default: 5

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  NODE_VERSION: '20'

jobs:
  research-validate-generate:
    runs-on: ubuntu-latest
    name: Research, Validate & Generate

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Determine parameters
        id: params
        run: |
          DATE=$(date +%Y-%m-%d)
          DAY_OF_WEEK=$(date +%u)

          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            COUNTRY="${{ inputs.country }}"
            CATEGORY="${{ inputs.category }}"
            NUM_QUESTIONS="${{ inputs.num_questions }}"
          else
            # Rotaci√≥n autom√°tica diaria
            case $DAY_OF_WEEK in
              1) COUNTRY="CO"; CATEGORY="mathematics" ;;
              2) COUNTRY="MX"; CATEGORY="science" ;;
              3) COUNTRY="BR"; CATEGORY="history" ;;
              4) COUNTRY="US"; CATEGORY="geography" ;;
              5) COUNTRY="CO"; CATEGORY="computers" ;;
              6) COUNTRY="MX"; CATEGORY="general_knowledge" ;;
              7) COUNTRY="BR"; CATEGORY="mathematics" ;;
            esac
            NUM_QUESTIONS=5
          fi

          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "country=$COUNTRY" >> $GITHUB_OUTPUT
          echo "category=$CATEGORY" >> $GITHUB_OUTPUT
          echo "num_questions=$NUM_QUESTIONS" >> $GITHUB_OUTPUT

          echo "üìÖ Date: $DATE"
          echo "üåç Country: $COUNTRY"
          echo "üìö Category: $CATEGORY"
          echo "üî¢ Questions: $NUM_QUESTIONS"

      - name: Research & Validate Questions from OpenTDB
        id: research
        run: |
          CATEGORY="${{ steps.params.outputs.category }}"
          NUM="${{ steps.params.outputs.num_questions }}"
          COUNTRY="${{ steps.params.outputs.country }}"

          # Mapear categor√≠a a ID de OpenTDB
          case "$CATEGORY" in
            "science") CAT_ID=17 ;;
            "mathematics") CAT_ID=19 ;;
            "history") CAT_ID=23 ;;
            "geography") CAT_ID=22 ;;
            "general_knowledge") CAT_ID=9 ;;
            "computers") CAT_ID=18 ;;
            *) CAT_ID=9 ;;
          esac

          echo "üîç Fetching from OpenTDB (Category ID: $CAT_ID)..."

          # Fetch con retry
          for i in 1 2 3; do
            curl -s "https://opentdb.com/api.php?amount=${NUM}&category=${CAT_ID}&type=multiple&encode=url3986" \
              -o /tmp/opentdb_raw.json && break
            echo "Retry $i..."
            sleep 2
          done

          # Validar y procesar respuesta
          node << 'VALIDATION_SCRIPT'
          const fs = require('fs');

          const data = JSON.parse(fs.readFileSync('/tmp/opentdb_raw.json', 'utf8'));

          if (data.response_code !== 0) {
            console.error('‚ùå API Error:', data.response_code);
            process.exit(1);
          }

          console.log(`‚úÖ Fetched ${data.results.length} questions from OpenTDB`);

          // Validar cada pregunta
          const validatedQuestions = [];
          const rejectedQuestions = [];

          data.results.forEach((q, i) => {
            const question = {
              id: i + 1,
              source: 'OpenTDB',
              source_url: 'https://opentdb.com',
              license: 'CC BY-SA 4.0',
              category: decodeURIComponent(q.category),
              difficulty: q.difficulty,
              original_question: decodeURIComponent(q.question),
              correct_answer: decodeURIComponent(q.correct_answer),
              incorrect_answers: q.incorrect_answers.map(a => decodeURIComponent(a)),
              original_language: 'en'
            };

            // VALIDACIONES
            const validations = {
              hasQuestion: question.original_question.length > 10,
              hasCorrectAnswer: question.correct_answer.length > 0,
              hasDistractors: question.incorrect_answers.length >= 3,
              noHtml: !/<[^>]*>/.test(question.original_question),
              notTooLong: question.original_question.length < 500,
              answersAreDifferent: new Set([question.correct_answer, ...question.incorrect_answers]).size === 4
            };

            const isValid = Object.values(validations).every(v => v);

            if (isValid) {
              question.validation_status = 'PASSED';
              question.validation_checks = validations;
              validatedQuestions.push(question);
              console.log(`  ‚úÖ Q${i+1}: Valid - "${question.original_question.substring(0, 50)}..."`);
            } else {
              question.validation_status = 'FAILED';
              question.validation_checks = validations;
              rejectedQuestions.push(question);
              console.log(`  ‚ùå Q${i+1}: Invalid - Failed checks: ${Object.entries(validations).filter(([k,v]) => !v).map(([k]) => k).join(', ')}`);
            }
          });

          console.log(`\nüìä Validation Summary:`);
          console.log(`   Valid: ${validatedQuestions.length}`);
          console.log(`   Rejected: ${rejectedQuestions.length}`);

          if (validatedQuestions.length === 0) {
            console.error('‚ùå No valid questions found!');
            process.exit(1);
          }

          // Guardar resultados
          fs.writeFileSync('/tmp/validated_questions.json', JSON.stringify({
            metadata: {
              source: 'OpenTDB',
              source_url: 'https://opentdb.com',
              license: 'CC BY-SA 4.0',
              fetch_date: new Date().toISOString(),
              total_fetched: data.results.length,
              total_valid: validatedQuestions.length,
              total_rejected: rejectedQuestions.length
            },
            questions: validatedQuestions,
            rejected: rejectedQuestions
          }, null, 2));

          console.log('\n‚úÖ Validation complete!');
          VALIDATION_SCRIPT

          echo "validated=true" >> $GITHUB_OUTPUT

      - name: Create Issue with Validated Questions
        id: create_issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('/tmp/validated_questions.json', 'utf8'));
            const country = '${{ steps.params.outputs.country }}';
            const category = '${{ steps.params.outputs.category }}';
            const date = '${{ steps.params.outputs.date }}';

            const countryMap = {
              'CO': { folder: 'saberparatodos/src/content/questions', lang: 'es', exam: 'Saber 11', name: 'Colombia', currency: 'COP', cities: ['Bogot√°', 'Medell√≠n', 'Cali'] },
              'MX': { folder: 'exani-mx/src/content/questions', lang: 'es', exam: 'EXANI-II', name: 'M√©xico', currency: 'MXN', cities: ['CDMX', 'Guadalajara', 'Monterrey'] },
              'BR': { folder: 'enem-br/src/content/questions', lang: 'pt', exam: 'ENEM', name: 'Brasil', currency: 'BRL', cities: ['S√£o Paulo', 'Rio', 'Bras√≠lia'] },
              'US': { folder: 'sat-us/src/content/questions', lang: 'en', exam: 'SAT', name: 'USA', currency: 'USD', cities: ['New York', 'Los Angeles', 'Chicago'] }
            };

            const config = countryMap[country] || countryMap['CO'];
            // Protocol V2.0: 7 questions per bundle (1 original + 2 easy + 2 medium + 2 hard)
            const questionsPerBundle = 7;
            const totalQuestions = data.questions.length * questionsPerBundle;

            // Crear cuerpo del issue simplificado (sin tablas markdown que causan errores YAML)
            let body = `## ü§ñ Task: Generate ${totalQuestions} Questions (Protocol V2.0)\n\n`;
            body += `> **Protocol Version:** 2.0 (7 questions per bundle)\n\n`;
            body += `### üìã Research Summary\n`;
            body += `- **Source:** ${data.metadata.source}\n`;
            body += `- **License:** ${data.metadata.license} ‚úÖ\n`;
            body += `- **Fetched:** ${data.metadata.total_fetched} questions\n`;
            body += `- **Validated:** ${data.metadata.total_valid} questions ‚úÖ\n`;
            body += `- **Rejected:** ${data.metadata.total_rejected} questions ‚ùå\n\n`;

            body += `### üåç Target Configuration\n`;
            body += `- **Country:** ${country} (${config.name})\n`;
            body += `- **Exam:** ${config.exam}\n`;
            body += `- **Language:** ${config.lang}\n`;
            body += `- **Category:** ${category}\n`;
            body += `- **Target Folder:** \`${config.folder}/${category}/\`\n\n`;

            body += `---\n\n`;
            body += `## üéØ VALIDATED Source Questions\n\n`;

            data.questions.forEach((q, i) => {
              body += `### ‚úÖ Source ${i + 1}: ${q.category} (${q.difficulty})\n\n`;
              body += `- **Original Question:** ${q.original_question}\n`;
              body += `- **Correct Answer:** ${q.correct_answer}\n`;
              body += `- **Incorrect Answers:** ${q.incorrect_answers.join(', ')}\n`;
              body += `- **Source:** ${q.source} (${q.source_url})\n`;
              body += `- **License:** ${q.license}\n\n`;
              body += `**Generate 7 questions (Protocol V2.0):**\n`;
              body += `1. Original (Difficulty 3) - Base question adapted\n`;
              body += `2. Easy A (Difficulty 1-2) - Simplified version\n`;
              body += `3. Easy B (Difficulty 1-2) - Different context\n`;
              body += `4. Medium A (Difficulty 3) - Practical application\n`;
              body += `5. Medium B (Difficulty 3) - Analysis/comparison\n`;
              body += `6. Hard A (Difficulty 4-5) - Multi-step problem\n`;
              body += `7. Hard B (Difficulty 4-5) - Complex reasoning\n\n---\n\n`;
            });

            body += `## ‚úÖ Acceptance Criteria (Protocol V2.0)\n\n`;
            body += `- [ ] Create ${data.questions.length} bundle files (7 questions each = ${totalQuestions} total)\n`;
            body += `- [ ] File naming: \`${country}-[CAT]-11-[topic]-[NNN]-bundle.md\`\n`;
            body += `- [ ] All files in \`${config.folder}/${category}/grado-11/\`\n`;
            body += `- [ ] Questions in **${config.lang}** language\n`;
            body += `- [ ] Include source attribution and \`protocol_version: "2.0"\`\n`;
            body += `- [ ] Use ${config.name} context (${config.currency}, ${config.cities.join(', ')})\n`;
            body += `- [ ] Include rich pedagogical explanations (competency, component, distractor analysis)\n`;

            // Crear el issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[V2.0] Generate ${data.questions.length} ${category} bundles for ${country} (${totalQuestions} questions)`,
              body: body
            });

            // Intentar agregar labels
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.data.number,
                labels: ['copilot', 'questions', 'automated', country.toLowerCase(), 'validated']
              });
            } catch (labelError) {
              console.log('Could not add labels: ' + labelError.message);
            }

            console.log('Created issue #' + issue.data.number);
            core.setOutput('issue_number', issue.data.number);
            return issue.data.number;

      - name: Assign Copilot Coding Agent
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt('${{ steps.create_issue.outputs.issue_number }}');

            console.log(`ü§ñ Assigning Copilot to issue #${issueNumber}...`);

            // Usar la API correcta para Copilot Coding Agent
            // Nota: Requiere que Copilot Coding Agent est√© habilitado en el repo
            try {
              const response = await github.request('POST /repos/{owner}/{repo}/issues/{issue_number}/assignees', {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                assignees: ['Copilot']
              });
              console.log('‚úÖ Copilot assigned successfully!');
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not assign Copilot: ${error.message}`);
              console.log('‚ÑπÔ∏è Note: Copilot Coding Agent must be enabled for this repository.');
              console.log('‚ÑπÔ∏è The issue was created successfully - manual assignment may be required.');
            }

      - name: Generate Summary
        run: |
          echo "## üìä Research & Generation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Date** | ${{ steps.params.outputs.date }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Country** | ${{ steps.params.outputs.country }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Category** | ${{ steps.params.outputs.category }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Issue Created** | #${{ steps.create_issue.outputs.issue_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Copilot Assigned** | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Copilot will generate question variations" >> $GITHUB_STEP_SUMMARY
          echo "2. A PR will be created automatically" >> $GITHUB_STEP_SUMMARY
          echo "3. Review and merge the PR" >> $GITHUB_STEP_SUMMARY
